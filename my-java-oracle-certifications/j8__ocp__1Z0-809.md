<pre>

Exam Details

	Exam Number: 1Z0-809
	Exam Title: Java SE 8 Programmer II

	Duration:	150 minutes
	Number of Questions:		85

	Passing Score:	65% 
	Beta exam scores will be available in CertView approximately August 31, 2015.


	View passing score policy
	Validated Against:	
	This exam is validated against Java SE 8.

	Format:	Multiple Choice
	Exam Price:	Rs 9701 More on exam pricing




ocp-j8_D84838GC10_1080544_US

	Oracle University | Contact Us: Local: 1800 103 4775 Intl: +91 80 67863102 

	Java SE 8 Programming 

	Duration: 5 Days 

	What you will learn 

	This Java SE 8 Programming training covers the core language features and Application Programming Interfaces (API) 
	you will use to design object-oriented applications with Java Standard Edition 8 (Java SE 8) Platform. 

	Learn To: 

	Create Java technology applications with the latest JDK Technology 
	Develop your object-oriented skills 
	Identify good practices in the use of the language to create robust Java application 
	Use Lambda expressions in Java applications 
	Store and manipulate data using collections 
	Manipulate files, directories and file systems 
	Connect to databases using standard SQL queries through JDBC 
	Create high-performance multi-threaded applications 

	Benefits to You 
	You can use this course to further develop your skills with the Java language and prepare for the Oracle Certified 
	Professional, Java SE 8 Programmer Exam! 

	Audience 

	Developer 
	Java Developers 
	Java EE Developers 

	Related Training 

	Required Prerequisites 

	Java SE 8 Fundamentals 

	Course Objectives 

	Creating high-performing multi-threaded applications 

	Creating Java technology applications that leverage the object-oriented features of the Java language, such as 

	encapsulation, inheritance, and polymorphism 

	Implementing input/output (I/O) functionality to read from and write to data and text files and understand advanced I/O 

	Copyright © 2013, Oracle. All rights reserved. Page 1 

	
	streams 

	Executing a Java technology application from the command line 

	Manipulating files, directories and file systems using the JDK NIO.2 specification 

	Creating applications that use the Java Collections framework 

	Performing multiple operations on database tables, including creating, reading, updating and deleting using both JDBC 

	and JPA technology 

	Searching and filter collections using Lambda Expressions 

	Implementing error-handling techniques using exception handling 

	Using Lambda Expression concurrency features 

	Course Topics 

		Java Platform Overview 

		Defining how the Java language achieves platform independence 
		Differentiating between the Java ME, Java SE, and Java EE Platforms 
		Evaluating Java libraries, middle-ware, and database options 
		Defining how the Java language continues to evolve 

		Java Syntax and Class Review 

		Creating simple Java classes 
		Creating primitive variables 
		Using operators 
		Creating and manipulate strings 
		Using if-else and switch statements 
		Iterating with loops: while,do-while,for,enhanced for 
		Creating arrays 
		Using Java fields, constructors, and methods 

		Encapsulation and Subclassing 

		Using encapsulation in Java class design 
		Modeling business problems using Java classes 
		Making classes immutable 
		Creating and use Java subclasses 
		Overloading methods 

		Overriding Methods, Polymorphism, and Static Classes 

		Using access levels: private, protected, default, and public. 
		Overriding methods 
		Using virtual method invocation 
		Using varargs to specify variable arguments 
		Using the instanceof operator to compare object types 
		Using upward and downward casts 
		Modeling business problems by using the static keyword 

		Copyright © 2013, Oracle. All rights reserved. Page 2 

		
		Implementing the singleton design pattern 

		Abstract and Nested Classes 

		Designing general-purpose base classes by using abstract classes 
		Constructing abstract Java classes and subclasses 
		Applying final keyword in Java 
		Distinguish between top-level and nested classes 

		Interfaces and Lambda Expressions 

		Defining a Java interface 
		Choosing between interface inheritance and class inheritance 
		Extending an interface 
		Defaulting methods 
		Anonymous inner classes 
		Defining a Lambda Expression 

		Collections and Generics 

		Creating a custom generic class 
		Using the type inference diamond to create an object 
		Creating a collection by using generics 
		Implementing an ArrayList 
		Implementing a TreeSet 
		Implementing a HashMap 
		Implementing a Deque 
		Ordering collections 

		Collections Streams, and Filters 

		Describing the Builder pattern 
		Iterating through a collection using lambda syntax 
		Describing the Stream interface 
		Filtering a collection using lambda expressions 
		Calling an existing method using a method reference 
		Chaining multiple methods together 
		Defining pipelines in terms of lambdas and collections 

		Lambda Built-in Functional Interfaces 

		Listing the built-in interfaces included in java.util.function 
		Core interfaces - Predicate, Consumer, Function, Supplier 
		Using primitive versions of base interfaces 
		Using binary versions of base interfaces 

		Lambda Operations 

		Extracting data from an object using map 
		Describing the types of stream operations 
		Describing the Optional class 
		Describing lazy processing 
		Sorting a stream 
		Saving results to a collection using the collect method 
		Grouping and partition data using the Collectors class 

		Exceptions and Assertions 

		Defining the purpose of Java exceptions 

		Copyright © 2013, Oracle. All rights reserved. Page 3 

		
		Using the try and throw statements 
		Using the catch, multi-catch, and finally clauses 
		Autoclose resources with a try-with-resources statement 
		Recognizing common exception classes and categories 
		Creating custom exceptions 
		Testing invariants by using assertions 
		Using the catch, multi-catch, and finally clauses 
		Autoclose resources with a try-with-resources statement 
		Recognizing common exception classes and categories 
		Creating custom exceptions 
		Testing invariants by using assertions 

		Java Date/Time API 

		Creating and manage date-based events 
		Creating and manage time-based events 
		Combining date and time into a single object 
		Working with dates and times across time zones 
		Managing changes resulting from daylight savings 
		Defining and create timestamps, periods and durations 
		Applying formatting to local and zoned dates and times 

		I/O Fundamentals 

		Describing the basics of input and output in Java 
		Read and write data from the console 
		Using streams to read and write files 
		Writing and read objects using serialization 

		File I/O (NIO.2) 

		Using the Path interface to operate on file and directory paths 
		Using the Files class to check, delete, copy, or move a file or directory 
		Using Stream API with NIO2 

		Concurrency 

		Describing operating system task scheduling 
		Creating worker threads using Runnable and Callable 
		Using an ExecutorService to concurrently execute tasks 
		Identifying potential threading problems 
		Using synchronized and concurrent atomic to manage atomicity 
		Using monitor locks to control the order of thread execution 
		Using the java.util.concurrent collections 

		The Fork-Join Framework 

		Parallelism 
		The need for Fork-Join 
		Work stealing 
		RecursiveTask 
		RecursiveTask 

		Parallel Streams 

		Reviewing the key characteristics of streams 
		Describing how to make a stream pipeline execute in parallel 
		List the key assumptions needed to use a parallel pipeline 
		Defining reduction 
		Describing why reduction requires an associative function 
		Calculating a value using reduce 
		Describing the process for decomposing and then merging work 
		Listing the key performance considerations for parallel streams 

		Copyright © 2013, Oracle. All rights reserved. Page 4 

		
		Database Applications with JDBC 

		Defining the layout of the JDBC API 
		Connecting to a database by using a JDBC driver 
		Submitting queries and get results from the database 
		Specifying JDBC driver information externally 
		Performing CRUD operations using the JDBC API 

		Localization 

		Describing the advantages of localizing an application 
		Defining what a locale represents 
		Read and set the locale by using the Locale object 
		Building a resource bundle for each locale 
		Calling a resource bundle from an application 
		Changing the locale for a resource bundle 

		Copyright © 2013, Oracle. All rights reserved. Page 5 

		



Sample Questions

	1. Given: 

	 
	public abstract class Customer { 
	 private String name; 
	 public Customer (String name) { 
	 this.name = name; 
	 } 
	 public String getName() { return name; } 
	 public abstract void buy(); 
	} 
	 
	Which two statements are true about Customer? 
	 
	A) The Customer class cannot be extended. 
	B) The Customer class cannot be instantiated. 
	C) Subclasses of Customer cannot override getName() method. 
	D) Concrete subclasses of Customer must use a default constructor. 
	E) Concrete subclasses of Customer must implement the buy() method. 
	F) Subclasses of Customer must implement the buy() method. 
	 
	 
	2. Given: 
	 
	class Toy { 
	 double price; 
	 String color; 
	 Toy(String color, double price) { 
	 this.color = color; 
	 this.price = price; 
	 } 
	 public double getPrice() { 
	 return price; 
	 } 
	 public String getColor() { 
	 return color; 
	 } 
	} 
	 
	And given the code fragment: 
	 
	List<Toy> toys = new ArrayList<>(); 
	toys.add(new Toy("red", 10)); 
	toys.add(new Toy("yellow", 10)); 
	toys.add(new Toy("red", 10)); 
	double totalPrice = toys.stream() 
	 .filter(e -> e.getColor() == "red") 
	 /* Line n1 */ 
	 .sum(); 
	System.out.println("Total Price of Red Toys: " + totalPrice); 
	 
	 
	 
	 
	 
	 
	 
	
	Which code fragment can be inserted at Line n1 to enable the code to print Total Price of Red Toys: 
	20.0? 
	 
	A) .flatMap(e -> e.getPrice()) 
	B) .mapToDouble(e -> e.getPrice()) 
	C) .map(e -> e.getPrice()) 
	D) .peek(e -> e.getPrice()) 
	 
	 
	3. Given the code fragment: 
	 
	class MyResource1 implements AutoCloseable { 
	 public void close() throws IOException { 
	 System.out.print("1 "); 
	 } 
	} 
	class MyResource2 implements Closeable { 
	 public void close() throws IOException { 
	 throw new IOException(); 
	 } 
	} 
	public class TestRes { 
	 public static void main(String[] args) { 
	 try (MyResource1 r1 = new MyResource1(); 
	 MyResource2 r2 = new MyResource2();) { 
	 System.out.print("T "); 
	 } catch (IOException ioe) { 
	 System.out.print("IOE "); 
	 } finally { 
	 System.out.print("F "); 
	 } 
	 } 
	} 
	 
	What is the result? 
	 
	A) T 1 IOE F 
	B) T IOE F 
	C) T IOE 1 F 
	D) Compilation fails. 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	
	4. Assuming that the TestResult.txt file exists and given the code fragment: 
	 
	public class TestReadFile { 
	 
	 public void readFile(String fName) throws IOException { 
	 // Line n1 
	 Stream<String> content = Files.lines(p); 
	 content.forEach(s1 -> System.out.println(s1)); 
	 } 
	 
	 public static void main(String[] args) throws IOException { 
	 TestReadFile trf = new TestReadFile(); 
	 trf.readFile("TestResult.txt "); 
	 
	 } 
	 
	} 
	 
	Which code fragment at Line n1 compiles? 
	 
	A) Path p = new Path(fName); 
	B) Path p = Paths.get(fName); 
	C) Path p = Paths.toPath(fName); 
	D) Path p = Paths.get(new File(fName)); 
	 
	 
	5. Which class definition compiles? 
	 
	A) class CallerThread1 implements Callable<String> { 
	 public String call() throws Exception { return "thread";} 
	 } 
	 
	B) class CallerThread2 implements Callable { 
	 public void call() {} 
	 } 
	 
	C) class CallerThread3 extends Callable { 
	 public void call() throws IOException {} 
	 } 
	 
	D) class CallerThread4 implements Callable<String> { 
	 public String call(String s) { return "thread";} 
	 } 
	 
	E) class CallerThread5 extends Callable<String> { 
	 public void callable(String s) throws Exception {} 
	 } 
	 
	 
	 
	
	 
	 
	 
	 
	 
	 
	 
	 
	6. Given the code fragment: 
	 Queue<String> products = new ArrayDeque<String>(); 
	 products.add("p1"); 
	 products.add("p2"); 
	 products.add("p3"); 
	 System.out.print(products.peek()); 
	 System.out.print(products.poll()); 
	 System.out.println(""); 
	 products.forEach(s -> System.out.print(s)); 
	 
	What is the result? 
	A. p1p1 

	p2p3 
	 
	B. p1p2 

	p1p2p3 
	 
	C. p1p2 

	p3 
	 
	D. p1p1 

	p1p2p3 
	 
	 
	7. Given the code fragment: 
	try (Connection con = DriverManager.getConnection(url, uname, pwd)) { 
	 Statement stmt = con.createStatement(); 
	 System.out.print(stmt.executeUpdate("INSERT INTO Emp VALUES (500,'Murray')")); 
	} 
	 
	Assuming the SQL query executes properly, what is the result? 
	A) true 
	B) false 
	C) 1 
	
	D) 0 
	 
	 
	 
	 
	 
	 
	 
	 
	8. Given the code fragment: 
	public class TestFun { 
	 public static void main(String[] args) { 
	 List<Integer> nums = Arrays.asList(1,2,3,4,5); 
	 // Line n1 
	 } 
	} 
	 
	Which code fragment can be inserted at Line n1 to enable the code to print 2 4? 
	A) nums.peek(n -> n%2 == 0) 
	 .forEach( s -> System.out.print(" "+s)); 
	 
	B) nums.filter(n -> n%2 == 0) 
	 .forEach( s -> System.out.print(" "+s)); 
	 
	C) nums.map(n -> n%2 == 0) 
	 .forEach( s -> System.out.print(" "+s)); 
	 
	D) nums.stream() 
	 .filter(n -> n%2 == 0) 
	 .forEach( s -> System.out.print(" "+s)); 
	 
	 
	Answers: 
	1. B and E 
	2. B 
	3. A 
	4. B 
	5. A 
	6. A 
	7. C 
	8. D 

	 
	


</pre>
