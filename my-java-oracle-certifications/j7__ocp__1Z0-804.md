<pre>

Exam Details

	Exam Number: 1Z0-804
	Exam Title: Java SE 7 Programmer II (retiring Dec 31, 2018)

	Duration:	150 minutes
	Number of Questions:	
	65

	Passing Score:	65%  
	View passing score policy
	Validated Against:	
	This exam is validated against Java SE 7.

	Format:	Multiple Choice
	Exam Price:	Rs 9701 More on exam pricing





ocp_j7_D67240GC20_1080544_US

	Oracle University | Contact Us: Local: 1800 103 4775 Intl: +91 80 4108 4709 

	Java SE 7 Programming 

	Duration: 5 Days 

	What you will learn 

	This Java Programming training covers the core Application Programming Interfaces (API) you'll use to design 
	object-oriented applications with Java. Expert Oracle University instructors will teach you how to write database 
	programs with JDBC. 

	Learn To: 

	Create Java technology applications with the latest JDK 7 Technology and the NetBeans Integrated Development 
	Environment (IDE). 
	Enhance object-oriented thinking skills using design patterns and best practices. 
	Identify good practices in the use of the language to create robust Java applications. 
	Manipulate files, directories and file systems. 
	Write database applications using standard SQL queries through JDBC. 
	Create high-performance, multi-threaded applications. 
	Create classes that subclass other classes, extend abstract classes and program with interfaces. 
	Properly use exceptions and the Collections framework. 
	Develop applications that manipulate files, directories and file systems. 

	Benefits to You 

	By enrolling in this course, you'll learn how to boost the productivity, communication and collaboration of your 
	organization. At the same time, you'll develop the knowledge and skills to reduce the cost of application ownership 
	through more efficient development and deployment techniques. Maintain your edge in the job market by staying current 
	with the global standard for developing networked applications. 

	Earn Your Java Certification 

	You can use this course to further develop your skills with the Java language. Immsersing yourself in this content will 
	help you prepare for the Oracle Certified Professional, Java SE 7 Programmer Exam. 

	Live Virtual Class Format 

	A Live Virtual Class (LVC) is exclusively for registered students; unregistered individuals may not view an LVC at any 
	time. Registered students must view the class from the country listed in the registration form. Unauthorized recording, 
	copying, or transmission of LVC content may not be made. 

	Audience 

	Copyright © 2013, Oracle. All rights reserved. Page 1 

	
	Developer 
	J2EE Developer 
	Java Developer 
	Java EE Developer 
	J2EE Developer 
	Java Developer 
	Java EE Developer 

	Related Training 

	Required Prerequisites 

	Experience with at least one programming language 

	Understand object-oriented principles 

	Basic understanding of database concepts and SQL syntax 

	Have completed the Java SE 7 Fundamentals course, or experience with the Java language - can create, compile and 

	execute programs 
	Java SE7 Fundamentals 

	Course Objectives 

	Process strings using a variety of regular expressions 

	Create high-performing multi-threaded applications that avoid deadlock 

	Localize Java applications 

	Create applications that use the Java Collections framework 

	Implement error-handling techniques using exception handling 

	Implement input/output (I/O) functionality to read from and write to data and text files and understand advanced I/O 

	streams 
	Manipulate files, directories and file systems using the JDK7 NIO.2 specification 
	Apply common design patterns and best practices 
	Create Java technology applications that leverage the object-oriented features of the Java language, such as 

	encapsulation, inheritance, and polymorphism 
	Execute a Java technology application from the command line 
	Perform multiple operations on database tables, including creating, reading, updating and deleting using JDBC 

	technology 

	Course Topics 

	Copyright © 2013, Oracle. All rights reserved. Page 2 

	
	Java Platform Overview 

	Introductions 
	Course Schedule 
	Java Overview 
	Java Platforms 
	OpenJDK 
	Licensing 
	Java in Server Environments 
	The Java Community Process 

	Java Syntax and Class Review 

	Simple Java classes 
	Java fields, constructors and methods 
	Model objects using Java classes 
	Package and import statements 

	Encapsulation and Polymorphism 

	Encapsulation in Java class design 
	Model business problems with Java classes 
	Immutability 
	Subclassing 
	Overloading methods 
	Variable argument methods 

	Java Class Design 

	Access modifiers: private, protected and public 
	Method overriding 
	Constructor overloading 
	The instanceof operator 
	Virtual method invocation 
	Polymorphism 
	Casting object references 
	Overriding Object methods 

	Advanced Class Design 

	Abstract classes and type generalization 
	The static and final modifiers 
	Field modifier best practices 
	The Singleton design pattern 
	Designing abstract classes 
	Nested classes 
	Enumerated types 

	Inheritance with Java Interfaces 

	Java Interfaces 
	Types of Inheritance 
	Object composition and method delegation 
	Implementing multiple interfaces 
	The DAO design pattern 

	Generics and Collections 

	Generic classes and type parameters 

	Copyright © 2013, Oracle. All rights reserved. Page 3 

	
	Type inference (diamond) 
	Collections and generics 
	List, set and Map 
	Stack and Deque 
	Collections and generics 
	List, set and Map 
	Stack and Deque 

	String processing 

	String manipulation with StringBuilder and StringBuffer 
	Essential String methods 
	Text parsing in Java 
	Input processing with Scanner 
	Text output and formatting 
	Regular expressions with the Pattern and Matcher classes 

	Exceptions and Assertions 

	Exceptions categories 
	Standard Java Exception classes 
	Creating your own Exception classes 
	Using try-catch and the finally clause 
	Using try-with-resources and the AutoCloseable interface 
	The multi-catch feature 
	Best practices using exceptions 
	Assertions 

	I/O Fundamentals 

	I/O using Java 
	Reading the console input stream 
	Writing to the console 
	Using I/O Streams 
	Chaining I/O Streams 
	Channel I/O 
	Reading and writing objects using Serialization 

	File I/O with NIO 2 

	The Path interface 
	The Files class 
	Directory and File operations 
	Managing file system attributes 
	Reading, writing, and creating files 
	Watching for file system changes 

	Threading 

	Operating system task scheduling 
	Recognizing multithreaded environments 
	Creating multi-threaded solutions 
	Sharing data across threads 
	Synchronization and Deadlock 
	Immutable objects 

	Concurrency 

	Creating Atomic variables 
	Using Read-Write Locks 
	Thread-safe collections 

	Copyright © 2013, Oracle. All rights reserved. Page 4 

	
	Concurrenct synchronizers (Semaphore, Phaser, and others) 
	Executors and ThreadPools to concurrently schedule tasks 
	Parallelism and the Fork-Join framework 
	Executors and ThreadPools to concurrently schedule tasks 
	Parallelism and the Fork-Join framework 

	Database Application with JDBC 

	Layout of the JDBC API 
	JDBC divers 
	Queries and results 
	PreparedStatement and CallableStatement 
	Transactions 
	RowSet 1.1 RowSetProvider and RowSetFactory 
	The DAO Pattern and JDBC 

	Localization 

	Advantages of localization 
	Defining locale 
	Read and set locale using the Locale object 
	Resource bundles 
	Format messages, dates and numbers 

	Copyright © 2013, Oracle. All rights reserved. Page 5 






Sample Questions

	Exam 804 – Sample Questions 
	 
	1.Given: 
	 
	class MySort implements Comparator<Integer> { 
	 public int compare(Integer x, Integer y) { 
	 return y.compareTo(x); 
	 } 
	} 
	 
	And the code fragment: 
	 
	 Integer[] primes = {2, 7, 5, 3}; 
	 MySort ms = new MySort(); 
	 Arrays.sort(primes, ms); 
	 for (Integer p2 : primes) { 
	 System.out.print(p2 + " "); 
	 } 
	 
	What is the result? 
	 
	A) 2 3 5 7 
	B) 2 7 5 3 
	C) 7 5 3 2 
	D) Compilation fails. 
	 
	2. Given: 
	 
	class Class1 { String v1; } 
	class Class2 { 
	 Class1 c1; 
	 String v2; 
	} 
	 
	class Class3 { 
	 Class2 c1; 
	 String v3; 
	} 
	 
	Which three options correctly describe the relationship between the classes? 
	 
	A) Class2 has-a v3 
	B) Class1 has-a v2 
	C) Class2 has-a v2 
	D) Class3 has-a v1 
	E) Class2 has-a Class3 
	F) Class2 has-a Class1 
	 
	 
	 
	 
	 
	 
	 
	 
	
	3. Given: 
	 
	class MyKeys { 
	 Integer key; 
	 MyKeys(Integer k) { 
	 key = k; 
	 } 
	 public boolean equals(Object o) { 
	 return ((MyKeys) o).key == this.key; 
	 } 
	} 
	 
	And this code snippet: 
	 
	Map m = new HashMap(); 
	MyKeys m1 = new MyKeys(1); 
	MyKeys m2 = new MyKeys(2); 
	MyKeys m3 = new MyKeys(1); 
	MyKeys m4 = new MyKeys(new Integer(2)); 
	m.put(m1, "car"); 
	m.put(m2, "boat"); 
	m.put(m3, "plane"); 
	m.put(m4, "bus"); 
	System.out.print(m.size()); 
	 
	What is the result? 
	 
	A) 2 
	B) 3 
	C) 4 
	D) Compilation fails. 
	 
	4. Given: 
	 
	import java.util.*; 
	public class MyScan { 
	 public static void main(String[] args) { 
	 String in = "1 a 10 . 100 1000"; 
	 Scanner s = new Scanner(in); 
	 int accum = 0; 
	 for (int x = 0; x < 4; x++) { 
	 accum += s.nextInt(); 
	 } 
	 System.out.println(accum); 
	 } 
	} 
	 
	What is the result? 
	 
	A) 11 
	B) 111 
	C) 1111 
	D) An exception is thrown at runtime. 
	 
	 
	
	 
	5. Given: 
	 
	public class Truthy { 
	 public static void main(String[] args) { 
	 int x = 7; 
	 assert (x == 6) ? "x == 6" : "x != 6"; 
	 } 
	} 
	 
	What is the result if you try to compile Truthy.java and then run it with assertions enabled? 
	 
	A) Truthy.java does NOT compile. 
	B) Truthy.java compiles and the output is x != 6. 
	C) Truthy.java compiles and an AssertionError is thrown with no additional output. 
	D) Truthy.java compiles and an AssertionError is thrown with x != 6 as additional output. 
	 
	6. Given the code fragment: 
	 
	try { 
	// assume "conn" is a valid Connection object 
	// assume a valid Statement object is created 
	// assume rollback invocations will be valid 
	 
	// use SQL to add 10 to a checking account 
	Savepoint s1 = conn.setSavePoint(); 
	// use SQL to add 100 to the same checking account 
	 
	Savepoint s2 = conn.setSavePoint(); 
	// use SQL to add 1000 to the same checking account 
	// insert valid rollback method invocation here 
	} catch (Exception e) { } 
	 
	Which two statements are true? 
	 
	A) If conn.rollback(s1) is inserted, account will be incremented by 10. 
	B) If conn.rollback(s1) is inserted, account will be incremented by 1010. 
	C) If conn.rollback(s2) is inserted, account will be incremented by 100. 
	D) If conn.rollback(s2) is inserted, account will be incremented by 110. 
	E) If conn.rollback(s2) is inserted, account will be incremented by 1110. 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	
	7. Given: 
	 
	public class Bees { 
	 public static void main(String[] args) { 
	 try { 
	 new Bees().go(); 
	 } catch (Exception e) { 
	 System.out.println("thrown to main"); 
	 } 
	 } 
	 synchronized void go() throws InterruptedException { 
	 Thread t1 = new Thread(); 
	 t1.start(); 
	 System.out.print("1 "); 
	 t1.wait(5000); 
	 System.out.print("2 "); 
	 } 
	} 
	 
	What is the result? 
	 
	A) The program prints 1 then 2 after 5 seconds 
	B) The program prints: 1 thrown to main 
	C) The program prints: 1 2 thrown to main 
	D) The program prints:1 then t1 waits for its notification. 
	 
	8. Given: 
	 
	import java.text.*; 
	public class Align { 
	 public static void main(String[] args) throws ParseException { 
	 String[] sa = {"111.234", "222.5678"}; 
	 NumberFormat nf = NumberFormat.getInstance(); 
	 nf.setMaximumFractionDigits(3); 
	 for (String s : sa) { 
	 System.out.println(nf.parse(s)); 
	 } 
	 } 
	} 
	 
	What is the result? 
	 
	A) 
	111.234 
	222.567 
	B) 
	111.234 
	222.568 
	C) 
	111.234 
	222.5678 
	D) An exception is thrown at runtime. 
	 
	
	Answers 
	1. C 
	2. C, D, F 
	3. C 
	4. D 
	5. A 
	6. A, D 
	7. B 
	8. C 
	 
	


</pre>
